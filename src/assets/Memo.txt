netstat -ano   查看所有端口使用情况
jenkins 启动   java -jar jenkins.war --httpPort=$xxxx 是使用某个端口启动 

Doctype的文档类型
    声明必须是 HTML 文档的第一行，位于 标签之前.
    声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。
    严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。
    DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现
    在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
    HTML5 只有一种<!DOCTYPE html>
    HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">

cookie、sessionSttorage、localStory区别
                    由谁初始化              过期时间        在当前浏览器会话中是否保持不变      是否与域名（domain）相关联      是否随着每个 HTTP 请求发送给服务器  容量（每个域名）    访问权限
cookie 客户端或服务器，服务器使用Set-Cookie请求头。手动设置         取决于是否设置了过期时间                是                       会在头问的cookie中发出             4KB          任意窗口                                 
localStorage        客户端                  永不过期                是                              否                              否                          5M             任意窗口
sessionStorage      客户端                  当前页面关闭时          否                               否                             否                          5M              任意窗口

HTML全局属性(global attribute)有哪些？
    class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素
    contenteditable: 指定元素内容是否可编辑
    contextmenu: 自定义鼠标右键弹出菜单内容
    data-*: 为元素增加自定义属性
    dir: 设置元素文本方向
    draggable: 设置元素是否可拖拽
    dropzone: 设置元素拖放类型： copy, move, link
    hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果
    id: 元素id，文档内唯一
    lang: 元素内容的的语言
    spellcheck: 是否启动拼写和语法检查
    style: 行内css样式
    tabindex: 设置元素可以获得焦点，通过tab可以导航
    title: 元素相关的建议信息
    translate: 元素和子孙节点内容是否需要本地化

常见的浏览器内核有哪些？
    Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
    Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
    Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]
    Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]
    浏览器内核的理解
        主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
        渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
        JS引擎则：解析和执行javascript来实现网页的动态效果。

    webSocket如何兼容低浏览器？
        Adobe Flash Socket
        ActiveX HTMLFile (IE)
        基于 multipart 编码发送 XHR
        基于长轮询的 XHR

如何实现浏览器内多个标签页之间的通信    WebSocket、SharedWorker；
    1. 使用localStorage 的 storage事件监听添加、修改、删除的动作
        window.addEventListener("storage",function(event){  
            $("#name").val(event.key+”=”+event.newValue);  
        }); 
    2. 使用cookie+setInterval

iframe有哪些缺点？
    frame会阻塞主页面的Onload事件(过多会增加服务器的HTTP请求)；
    搜索引擎的检索程序无法解读这种页面，不利于SEO;
    页面样式调试麻烦，出现多个滚动条；
    浏览器的后退按钮失效
    产生多个页面，不易管理
    不容易打印
    iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
    改进：使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题

HTML5有哪些新特性？
    语意化标签 article、footer、header、nav、section
    新增选择器 document.querySelector、document.querySelectorAll
    拖拽释放(Drag and drop) API
    媒体播放的 video 和 audio
    本地存储 localStorage 和 sessionStorage
    离线应用 manifest
    桌面通知 Notifications
    增强表单控件 calendar、date、time、email、url、search
    地理位置 Geolocation
    多任务 webworker
    全双工通信协议 websocket
    历史管理 history
    跨域资源共享(CORS)` Access-Control-Allow-Origin
    页面可见性改变事件 visibilitychange
    跨窗口通信 PostMessage
    Form Data 对象
    绘画 canvas
正则: {
    'fdaf'.match(/\d{1,4}/);  返回符合的指定的值.
    temp.toString().match(/^\d+(?:\.\d{0,2})?/)    
    str.replace(/*ssx/, '')  替换字符串
    /xxxx/.exec(string);
    RegExp 
        var patt1=new RegExp("e");
        对象有 3 个方法：test()、exec() 以及 compile()。
        test() 方法检索字符串中的指定值。返回值是 true 或 false。 new RegExp("e").test("aa");
        exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。
            //例：/{{[ \t]*([\w\W]*?)[ \t]*}}/g.exec('{{abcd}}')
        compile() 方法用于改变 RegExp。
        "(exp)"    匹配exp,并捕获文本到自动命名的组里
        "(?<name>exp)"   匹配exp,并捕获文本到名称为name的组里
        "(?:exp)"  匹配exp,不捕获匹配的文本，也不给此分组分配组号
        以下为零宽断言
        "(?=exp)"  匹配exp前面的位置   (?!p) 是(?=exp) 的反操作
        　　如 "How are you doing" 正则"(?<txt>.+(?=ing))" 这里取ing前所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为"How are you do";
        "(?<=exp)"  匹配exp后面的位置
        　　如 "How are you doing" 正则"(?<txt>(?<=How).+)" 这里取"How"之后所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为" are you doing";  
        "(?!exp)"   匹配后面跟的不是exp的位置
    　　如 "123abc" 正则 "\d{3}(?!\d)"匹配3位数字后非数字的结果
        "(?<!exp)"  匹配前面不是exp的位置
    　　如 "abc123" 正则 "(?<![0-9])123" 匹配"123"前面是非数字的结果也可写成"(?!<\d)123"
        RegExp.$1 - $9 在
    符号
        * 零次或多次  ？ 0次或一次  +  一次或多次
        \w  匹配字母或数字或下划线或汉字 
        \s  匹配任意的空白符
        \A  以字符串开头    \Z 字符串结尾或行尾   \z字符串结尾类似$   \e Escape  ,  \n 换行符 ，  \r 回车
        \W  匹配任意不是字母，数字，下划线，汉字的字符
        \S  匹配任意不是空白符的字符
        \D  匹配任意非数字的字符
        \B  匹配不是单词开头或结束的位置
        [^x]    匹配除了x以外的任意字符
        \b  匹配单词的开始或结束
    匹配双字节字符(包括汉字在内)：[^\x00-\xff]
    /{{[ \t]*([\w\W]*?)[ \t]*}}/g   //用于匹配和分割用{{}}
    html.replace(/<(?:.|\s)*?>/g, "")   //把 <xxxx> 这种替换成空
    正则匹配空  可以使用 /^$/.test();
    正则匹配0到1之间的(包括0和1) /^(?:0(?:\.[0-9]+){0,1}|1)$/.test(xxx); 
    this.replace(/(^\s*)|(\s*$)/g, '')  //trim 效果清空二边空格  
    /(<[^>^<]*>)/g     去除html标签  （/<.*?>/g ）之前是用的这个
    "12345678".replace(/(?=(\d{3})+$)/g, ',');     数字三位隔开
    /(\d{4})-(\d{2})-(\d{2})/.test("2017-06-12")        RegExp.$1  -9

    在使用/g全局搜索的时候,正则会把lastindexof保留下来，导致出现问题  //https://segmentfault.com/q/1010000011857035
    https://segmentfault.com/a/1190000015333121  正则表达式学习网站 
},
js  
    typeof 陷阱
        主要是 typeof null == 'object'   需要判断是否为null    typeof [] == 'object'   需要先用isArray判断一下
    javascript数据类型
        undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object） Symbol(独一无二的值)
    try{} catch(err) {} finally{}
        finally在try 或 catch 之后运行, 不管对错都会执行.    finally中的return 把之前的覆盖掉   finally中如果返回错，则会反之前的错替换掉，只返回finally的错的
 
https://my.oschina.net/maomi/blog/88086
移动端touch事件(区分webkit 和 winphone)
    当用户手指放在移动设备在屏幕上滑动会触发的touch事件
    以下支持webkit
    touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指
    touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动
    touchend——当手指离开屏幕时触发
    touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用TouchEvent
    touches：屏幕上所有手指的信息
    targetTouches：手指在目标区域的手指信息
    changedTouches：最近一次触发该事件的手指信息
    touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息参数信息(changedTouches[0])
    clientX、clientY在显示区的坐标
    target：当前元素

手动触发一个dom事件，需要3步，如果你对document.createEvent,
    创建一个事件对象 document.createEvent(event)
    初始化事件对象 event.initEvent(type, bubbles, true)
    分发事件 dom.dispatchEvent(event)
网页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth (包括边线的宽);
网页可见区域高： document.body.offsetHeight (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
屏幕可用工作区宽度：window.screen.availWidth;
scrollHeight: 获取对象的滚动高度。 
scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离
scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离
scrollWidth:获取对象的滚动宽度
offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度
offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置
offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 
event.clientX 相对文档的水平座标
event.clientY 相对文档的垂直座标
event.offsetX 相对容器的水平坐标
event.offsetY 相对容器的垂直坐标 
document.documentElement.scrollTop 垂直方向滚动的值
event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量
documnet.getBoundingClientRect();   这个方法取到的值是根据这个浏览器的窗口来算的，而不是根据整个文档来算的
document.documentElement.scrollHeight  =  document.documentElement.scrollTop + document.documentElement.clientHeight  

Window 方法
    window.innerHeight - 浏览器窗口的内部高度   不包括地址栏，导航栏
    window.innerWidth - 浏览器窗口的内部宽度
    window.open() - 打开新窗口
    window.close() - 关闭当前窗口
    window.moveTo() - 移动当前窗口
    window.resizeTo() - 调整当前窗口大小
    window.screen.availWidth - 可用的屏幕宽度
    screen.availHeight - 可用的屏幕高度
    location.hostname 返回 web 主机的域名
    location.pathname 返回当前页面的路径和文件名
    window.location.origin 返回当前的域名
    location.port 返回 web 主机的端口 （80 或 443）
    location.protocol 返回所使用的 web 协议（http:// 或 https://）
    location.href 属性返回当前页面的 URL。
    history.back() - 与在浏览器点击后退按钮相同
    history.forward() - 与在浏览器中点击按钮向前相同



2、Touch事件与Mouse事件的出发关系
在触屏操作后，手指提起的一刹那（即发生ontouchend后），系统会判断接收到事件的element的内容是否被改变，如果内容被改变，接下来的事 件都不会触发，如果没有改变，
会按照mousedown，mouseup，click的顺序触发事件。特别需要提到的是，只有再触发一个触屏事件时，才会 触发上一个事件的mouseout事件。


Object.preventExtensions(obj)  让一个对象变的不可扩展，也就是永远不能再添加新的属性。
Object.isExtensible(obj) 判断一个对象是否是可扩展的
Object.seal(obj)让一个对象密封(只能读写 不能新增)
Object.isSealed(obj)判断一个对象是否密封
Object.isFrozen(arr)  让一个对象被冻结(只能读)
Object.isFrozen(obj)：判断一个对象是否被冻结
Object.keys(obj) 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组
Object.getOwnPropertyNames(obj)：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组
Object.is(value1, value2)：判断两个值是否是同一个值,Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
Object.create(proto [, propertiesObject ]) 是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个参数是对象的属性描述符，这个参数是可选的。
Object.assign 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。【浅复制】
//var copy = Object.assign({}, obj);
Object.defineProperty() 定义单个对象属性或方法(可以设置读写可枚举)
Object.defineProperties() 定义多个对象属性或方法(可以设置读写可枚举)
Object.freeze() 阻止修改现有属性的特性和值，并阻止添加新属性。 

Object.assign() //浅拷贝，类似{...obj1,...obj2} 都是浅拷贝
Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）
Object.getPrototypeOf(ColorPoint) === Point  以使用这个方法判断，一个类是否继承了另一个类。
Object.setPrototypeOf  为现有对象设置原型，返回一个新对象
Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（ descriptor ）。
    var obj = { p: 'a' }; Object.getOwnPropertyDescriptor(obj, 'p')Object { value: "a",writable: true,enumerable: true,configurable: true}

var target = { a: 1 };
var source1 = { b: 2 };
var source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

//如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。

Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。

var obj1 = {a: {b: 1}};
var obj2 = Object.assign({}, obj1);
obj1.a.b = 2;
obj2.a.b // 2

对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。
var target = { a: { b: 'c', d: 'e' } }
var source = { a: { b: 'hello' } }
Object.assign(target, source)
// { a: { b: 'hello' } }


一、节点
1.1 节点属性
Node.nodeName   //返回节点名称，只读
Node.nodeType   //返回节点类型的常数值，只读    1-element-元素 2-attr-属性 3-text-文本内容  9-Document-整个文档
Node.nodeValue  //返回Text或Comment节点的文本值，只读
Node.textContent  //返回当前节点和它的所有后代节点的文本内容，可读写
Node.baseURI    //返回当前网页的绝对路径

Node.ownerDocument  //返回当前节点所在的顶层文档对象，即document
Node.nextSibling  //返回紧跟在当前节点后面的第一个兄弟节点
Node.previousSibling  //返回当前节点前面的、距离最近的一个兄弟节点
Node.parentNode   //返回当前节点的父节点
Node.parentElement  //返回当前节点的父Element节点
Node.childNodes   //返回当前节点的所有子节点
Node.firstChild  //返回当前节点的第一个子节点
Node.lastChild   //返回当前节点的最后一个子节点

//parentNode接口
Node.children  //返回指定节点的所有Element子节点
Node.firstElementChild  //返回当前节点的第一个Element子节点
Node.lastElementChild   //返回当前节点的最后一个Element子节点
Node.childElementCount  //返回当前节点所有Element子节点的数目。
1.2 操作
Node.appendChild(node)   //向节点添加最后一个子节点
Node.hasChildNodes()   //返回布尔值，表示当前节点是否有子节点
Node.cloneNode(true);  // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)
Node.insertBefore(newNode,oldNode)  // 在指定子节点之前插入新的子节点
Node.removeChild(node)   //删除节点，在要删除节点的父节点上操作
Node.replaceChild(newChild,oldChild)  //替换节点
Node.contains(node)  //返回一个布尔值，表示参数节点是否为当前节点的后代节点。
Node.compareDocumentPosition(node)   //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系
Node.isEqualNode(noe)  //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。
Node.normalize()   //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。

//ChildNode接口
Node.remove()  //用于删除当前节点
Node.before()  //
Node.after()
Node.replaceWith()
1.3 Document节点
1.3.1 Document节点的属性
document.doctype   //
document.documentElement  //返回当前文档的根节点
document.defaultView   //返回document对象所在的window对象
document.body   //返回当前文档的<body>节点
document.head   //返回当前文档的<head>节点
document.activeElement  //返回当前文档中获得焦点的那个元素。

//节点集合属性
document.links  //返回当前文档的所有a元素
document.forms  //返回页面中所有表单元素
document.images  //返回页面中所有图片元素
document.embeds  //返回网页中所有嵌入对象
document.scripts  //返回当前文档的所有脚本
document.styleSheets  //返回当前网页的所有样式表

//文档信息属性
document.documentURI  //表示当前文档的网址
document.URL  //返回当前文档的网址
document.domain  //返回当前文档的域名
document.lastModified  //返回当前文档最后修改的时间戳
document.location  //返回location对象，提供当前文档的URL信息
document.referrer  //返回当前文档的访问来源
document.title    //返回当前文档的标题
document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。
document.readyState  //返回当前文档的状态
document.designMode  //控制当前文档是否可编辑，可读写
document.compatMode  //返回浏览器处理文档的模式
document.cookie   //用来操作Cookie
1.3.2 Document节点的方法
（1）读写方法
document.open()   //用于新建并打开一个文档
document.close()   //不安比open方法所新建的文档
document.write()   //用于向当前文档写入内容
document.writeIn()  //用于向当前文档写入内容，尾部添加换行符。
（2）查找节点
document.querySelector(selectors)   //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。
document.querySelectorAll(selectors)  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。
document.getElementsByTagName(tagName)  //返回所有指定HTML标签的元素
document.getElementsByClassName(className)   //返回包括了所有class名字符合指定条件的元素
document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如<form>、<radio>、<img>、<frame>、<embed>和<object>等）
document.getElementById(id)   //返回匹配指定id属性的元素节点。
document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。
（3）生成节点
document.createElement(tagName)   //用来生成HTML元素节点。
document.createTextNode(text)   //用来生成文本节点
document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。
document.createDocumentFragment()  //生成一个DocumentFragment对象
（4）事件方法
document.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用
document.addEventListener(type,listener,capture)  //注册事件
document.removeEventListener(type,listener,capture)  //注销事件
document.dispatchEvent(event)  //触发事件
（5）其他
document.hasFocus()   //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。
document.adoptNode(externalNode)  //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。
document.importNode(externalNode, deep)   //从外部文档拷贝指定节点，插入当前文档。
1.4 Element节点
1.4.1 Element节点的属性
（1）特性属性
Element.attributes  //返回当前元素节点的所有属性节点
Element.id  //返回指定元素的id属性，可读写
Element.tagName  //返回指定元素的大写标签名
Element.innerHTML   //返回该元素包含的HTML代码，可读写
Element.outerHTML  //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写
Element.className  //返回当前元素的class属性，可读写
Element.classList  //返回当前元素节点的所有class集合
Element.dataset   //返回元素节点中所有的data-*属性。
（2）尺寸属性
Element.clientHeight   //返回元素节点可见部分的高度
Element.clientWidth   //返回元素节点可见部分的宽度
Element.clientLeft   //返回元素节点左边框的宽度
Element.clientTop   //返回元素节点顶部边框的宽度
Element.scrollHeight  //返回元素节点的总高度
Element.scrollWidth  //返回元素节点的总宽度
Element.scrollLeft   //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置
Element.scrollTop   //返回元素节点的垂直滚动向下滚动的像素数值
Element.offsetHeight   //返回元素的垂直高度(包含border,padding)
Element.offsetWidth    //返回元素的水平宽度(包含border,padding)
Element.offsetLeft    //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移
Element.offsetTop   //返回水平位移
Element.style  //返回元素节点的行内样式
（3）节点相关属性
Element.children   //包括当前元素节点的所有子元素
Element.childElementCount   //返回当前元素节点包含的子HTML元素节点的个数
Element.firstElementChild  //返回当前节点的第一个Element子节点  
Element.lastElementChild   //返回当前节点的最后一个Element子节点  
Element.nextElementSibling  //返回当前元素节点的下一个兄弟HTML元素节点
Element.previousElementSibling  //返回当前元素节点的前一个兄弟HTML节点
Element.offsetParent   //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。
1.4.2 Element节点的方法
（1）位置方法
getBoundingClientRect()  
// getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高
// top 元素上外边界距窗口最上面的距离
// right 元素右外边界距窗口最上面的距离
// bottom 元素下外边界距窗口最上面的距离
// left 元素左外边界距窗口最上面的距离
// width 元素自身宽(包含border,padding) 
// height 元素自身高(包含border,padding) 

getClientRects()   //返回当前元素在页面上形参的所有矩形。

// 元素在页面上的偏移量  
var rect = el.getBoundingClientRect()  
return {   
  top: rect.top + document.body.scrollTop,   
  left: rect.left + document.body.scrollLeft  
}
（2）属性方法
Element.getAttribute()：读取指定属性  
Element.setAttribute()：设置指定属性  
Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  
Element.removeAttribute()：移除指定属性
（3）查找方法
Element.querySelector()  
Element.querySelectorAll()  
Element.getElementsByTagName()  
Element.getElementsByClassName()
（4）事件方法
Element.addEventListener()：添加事件的回调函数  
Element.removeEventListener()：移除事件监听函数  
Element.dispatchEvent()：触发事件

//ie8
Element.attachEvent(oneventName,listener)
Element.detachEvent(oneventName,listener)

// event对象  
var event = window.event||event;    

// 事件的目标节点  
var target = event.target || event.srcElement;

// 事件代理  
ul.addEventListener('click', function(event) {   
  if (event.target.tagName.toLowerCase() === 'li') {   
    console.log(event.target.innerHTML)   
  }  
});
（5）其他
Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域

//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。
Element.insertAdjacentHTML(where, htmlString); 
Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入  
Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入 
Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入 
Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入

Element.remove()  //用于将当前元素节点从DOM中移除
Element.focus()   //用于将当前页面的焦点，转移到指定元素上
二、CSS操作
（1）类名操作
//ie8以下
Element.className  //获取元素节点的类名
Element.className += ' ' + newClassName  //新增一个类名

//判断是否有某个类名
function hasClass(element,className){
  return new RegExp(className,'gi').test(element.className);
}

//移除class
function removeClass(element,className){
  element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'),'');
}

//ie10 
element.classList.add(className)  //新增
element.classList.remove(className)  //删除
element.classList.contains(className)  //是否包含
element.classList.toggle(className)  //toggle class
（2）style操作
element.setAttribute('style','')
element.style.backgroundColor = 'red'
element.style.cssText //用来读写或删除整个style属性
element.style.setProperty(propertyName,value)  //设置css属性
element.style.getPropertyValue(property)  //获取css属性
element.style.removeProperty(property)  //删除css属性
操作非内联样式
//ie8
element.currentStyle[attrName]
//ie9+
window.getComputedStyle(el,null)[attrName] 
window.getComputedStyle(el,null).getPropertyValue(attrName)
//伪类
window.getComputedStyle(el,':after')[attrName]
三、对象
3.1 Object对象
（1）生成实例对象
var o = new Object()
（2）属性
Object.prototype   //返回原型对象
（3）方法
Object.keys(o)   //遍历对象的可枚举属性
Object.getOwnPropertyName(o)   //遍历对象不可枚举的属性
对象实例的方法
valueOf()：返回当前对象对应的值。  
toString()：返回当前对象对应的字符串形式。  
toLocaleString()：返回当前对象对应的本地字符串形式。  
hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 
isPrototypeOf()：判断当前对象是否为另一个对象的原型。
propertyIsEnumerable()：判断某个属性是否可枚举。

3.2 Array对象
（1）生成实例对象
var a = new Array()
（2）属性
a.length  //长度
（3）Array.isArray()
Array.isArray(a)   //用来判断一个值是否为数组
（4）Array实例的方法

[1, [2, [3, 4]]].toString() // "1,2,3,4"
a.valueof()   //返回数组本身
a.toString()  //返回数组的字符串形式
a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。
pop()   //用于删除数组的最后一个元素，并返回该元素
join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。
concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。
shift()  //用于删除数组的第一个元素，并返回该元素。
unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。
reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组
slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。
splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。
sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。
map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。
map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。
forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。
filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。
some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。
every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。
reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）
reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）
indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置
lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。
fill()  //使用固定的值填充数据


3.3 Number对象
（1）生成对象
var n = new Number()
（2）Number对象的属性
Number.POSITIVE_INFINITY：正的无限，指向Infinity。  
Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。  
Number.NaN：表示非数值，指向NaN。  
Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。  
Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。  
Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。  
Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。
（4）Number对象实例的方法
toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。
toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。
toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。
toPrecision()  //用于将一个数转为指定位数的有效数字。
3.4 String 对象
（1）生成实例对象
var s = new String()
（2）String对象的属性
s.length   //返回字符串的长度
（3）方法
s.chatAt(index)   //返回指定位置的字符    //"123456"[0] == "1"
s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。
s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）
s.concat(s2)  //用于连接两个字符串
s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。
s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。
s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。
s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 
s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。
s.trim()  //用于去除字符串两端的空格，返回一个新字符串
s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。
s.toUpperCase()  //全部转为大写
s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。
s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。
s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。
s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。
    第二个参数,可以是替换的string类型, 也可以是一个function, 例如换成大小写的方法, g
    第三个方法是输出格式 name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1");  一般是使用正则的$1, $2 这种匹配方式  
s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。
String.fromCharCode(numX,numX,...,numX)   把十进制的数字转换成指定的 Unicode 值,(在写字体转换的时候,用到过这个属性)


3.5 Math对象
（1）属性
Math.E：常数e。  
Math.LN2：2的自然对数。  
Math.LN10：10的自然对数。  
Math.LOG2E：以2为底的e的对数。  
Math.LOG10E：以10为底的e的对数。  
Math.PI：常数Pi。  
Math.SQRT1_2：0.5的平方根。  
Math.SQRT2：2的平方根。
（2）数学方法
Math.abs()：返回参数的绝对值  
Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 
Math.floor()：向下取整  
Math.max(n,n1,...)：可接受多个参数，返回最大值  
Math.min(n,n1,..)：可接受多个参数，返回最小值  
Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 
Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。  
Math.log()：返回以e为底的自然对数值。
Math.exp()：返回e的指数，也就是常数e的参数次方。
Math.round()：四舍五入  
Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。  Math.floor((Math.random()*10));   取0 - 10 之间的随机数 
（3）三角函数方法
Math.sin()：返回参数的正弦  
Math.cos()：返回参数的余弦  
Math.tan()：返回参数的正切  
Math.asin()：返回参数的反正弦（弧度值）  
Math.acos()：返回参数的反余弦（弧度值）  
Math.atan()：返回参数的反正切（弧度值）
3.6 JSON对象
（1）方法
JSON.stringify()   
//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。
//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。
//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。

JSON.parse()   //用于将JSON字符串转化成对象。


3.7 console对象
（1）方法
console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。
console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；
console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈
console.table()  //可以将复合类型的数据转为表格显示。
console.count()  //用于计数，输出它被调用了多少次。
console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。
console.dirxml()  //用于以目录树的形式，显示DOM节点。
console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。

//这两个方法用于计时，可以算出一个操作所花费的准确时间。
console.time()
console.timeEnd()
//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。

console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。
console.profileEnd()  //用来结束正在运行的性能测试器。

console.group()
console.groupend()
//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。
console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。

console.trace()  //显示当前执行的代码在堆栈中的调用路径。
console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。


正则表达式：
只允许输入汉字：onkeyup="value=value.replace(/[^\u4E00-\u9FA5]/g,'')" 
只允许输入数字：onkeyup="this.value=this.value.replace(/\D/g,'')"
[1, [2, [3, 4]]].toString() // "1,2,3,4"0、常用选择器
$('#div1')   //id为div1的节点，如<div id='div1'></div> 
$('span')   //所有的span结点，一个包装集
$('p span')   //p标签下的所有span节点，后代节点
$('p>span')   //p标签下的所有span子节点，子代节点

$('.red')  //使用样式red的节点，如<span class="red"></span>
$('*')  //所有节点
$("div,span,p.cls")  //选取所有<div>，<span>和拥有class为cls的<p>标签的一组元素


1、基本筛选器
$('span:first')    //第一个节点
$('span:last')     //最后一个节点
$("td:even")     //索引为偶数的节点，从 0 开始
$("td:odd")      //索引为奇数的节点，从 0 开始
$("td:eq(1)")    //给定索引值的节点
$("td:gt(0)")    //大于给定索引值的节点
$("td:lt(2)")    //小于给定索引值的节点
$(":focus")      //当前获取焦点的节点
$(":animated")   //正在执行动画效果的节点

2、内容选择器
$("div:contains('hello')")    //包含hello文本的节点
$("td:empty")    //不包含子节点或者文本的空节点
$("div:has(p)")  //含有选择器所匹配的节点
$("td:parent")   //含有子节点或者文本的节点

3、表单选择器
$("input:checked")    //所有选中的节点
$("select option:selected")    //select中所有选中的option节点
$(":input")      //匹配所有 input, textarea, select 和 button 节点
$(":text")       //所有的单行文本框
$(":password")   //所有密码框
$(":radio")      //所有单选按钮
$(":checkbox")   //所有复选框
$(":submit")     //所有提交按钮
$(":reset")      //所有重置按钮
$(":button")     //所有button按钮
$(":file")       //所有文件域

4、筛选与查找
$("p").eq(0)       //当前操作中第N个jQuery对象,类似索引
$('li').first()    //第一个节点
$('li').last()     //最后一个节点
$(this).hasClass("node")    //节点是否含有某个特定的类,返回布尔值
$('li').has('ul')  //包含特定后代的节点
$("div").children()      //div中的每个子节点,第一层
$("div").find("span")    //查找div下的所有span节点
$("p").next()       　　　//紧邻p节点后的一个同辈节点
$("p").nextAll()         //p节点之后所有的同辈节点
$("#node").nextUntil("#node2")    //id为"#node"节点之后到id为'#node2'之间所有的同辈节点,掐头去尾
$("p").prev()            //紧邻p节点前的一个同辈节点
$("p").prevAll()         //p节点之前所有的同辈节点
$("#node").prevUntil("#node2")    //id为"#node"节点之前到id为'#node2'之间所有的同辈节点,掐头去尾
$("p").parent()          //每个p节点的父节点
$("p").parents()         //每个p节点的所有祖先节点,body,html
$("#node").parentsUntil("#node2")    //id为"#node"节点到id为'#node2'之间所有的父级节点,掐头去尾
$("div").siblings()      //所有的同辈节点,不包括自己

5、属性操作
$("img").attr("src");    　　　　　　 //返回文档中所有图像的src属性值
$("img").attr("src","node.jpg");    //设置所有图像的src属性
$("img").removeAttr("src");    　　　//将文档中图像的src属性删除
$("input[type='checkbox']").prop("checked", true);    //选中复选框
$("input[type='checkbox']").prop("checked", false);   //不选中复选框
$("img").removeProp("src");    　　 //删除img的src属性

6、样式操作
$("p").addClass("selected");    　　//为p节点加上 'selected' 类
$("p").removeClass("selected");    //从p节点中删除 'selected' 类
$("p").toggleClass("selected");    //如果存在就删除,否则就添加HTML代码/文本/值

7、内容操作
$('p').html();    　　　　　　　　　　 //返回p节点的html内容
$("p").html("Hello <b>hello</b>!");  //设置p节点的html内容
$('p').text();    　　　　　　　　　　 //返回p节点的文本内容
$("p").text("hello");    　　　　　　　//设置p节点的文本内容
$("input").val();    　　　　　　　　 //获取文本框中的值
$("input").val("hello");     　　　　 //设置文本框中的内容

8、CSS操作
$("p").css("color");          //访问查看p节点的color属性
$("p").css("color","red");    //设置p节点的color属性为red
$("p").css({ "color": "red", "background": "yellow" });    //设置p节点的color为red，background属性为yellow（设置多个属性要用{}字典形式）

9、定位与偏移
$('p').offset()     //节点在当前视口的相对偏移,对象 {top: 5, left: 9}
$('p').offset().top
$('p').offset().left
$("p").position()   //节点相对父节点的偏移,对可见节点有效，Object {top: 5, left: 8}

$(window).scrollTop()    //获取滚轮滑的高度
$(window).scrollLeft()   //获取滚轮滑的宽度
$(window).scrollTop('25')    //设置滚轮滑的高度为25

10、尺寸
$("p").height();    //获取p节点的高度
$("p").width();     //获取p节点的宽度
$("p:first").innerHeight()    //获取第一个匹配节点内部区域高度(包括补白、不包括边框)
$("p:first").innerWidth()     //获取第一个匹配节点内部区域宽度(包括补白、不包括边框)
$("p:first").outerHeight()    //匹配节点外部高度(默认包括补白和边框)
$("p:first").outerWidth()     //匹配节点外部宽度(默认包括补白和边框)
$("p:first").outerHeight(true)    //为true时包括边距

11、DOM内部插入
$("p").append("<b>hello</b>");    //每个p节点内后面追加内容
$("p").appendTo("div");    　　　 //p节点追加到div内后
$("p").prepend("<b>Hello</b>");  //每个p节点内前面追加内容
$("p").prependTo("div");    　   //p节点追加到div内前

12、DOM外部插入
$("p").after("<b>hello</b>");     //每个p节点同级之后插入内容
$("p").before("<b>hello</b>");    //在每个p节点同级之前插入内容
$("p").insertAfter("#node");     //所有p节点插入到id为node节点的后面
$("p").insertBefore("#node");    //所有p节点插入到id为node节点的前面

13、DOM替换
$("p").replaceWith("<b>Paragraph. </b>");    //将所有匹配的节点替换成指定的HTML或DOM节点
$("<b>Paragraph. </b>").replaceAll("p");     //用匹配的节点替换掉所有 selector匹配到的节点

14、DOM删除
$("p").empty();     //删除匹配的节点集合中所有的子节点，不包括本身
$("p").remove();    //删除所有匹配的节点,包括本身
$("p").detach();    //删除所有匹配的节点(和remove()不同的是:所有绑定的事件、附加的数据会保留下来)

15、DOM复制
$("p").clone()    　　//克隆节点并选中克隆的副本
$("p").clone(true)   //布尔值指事件处理函数是否会被复制

16、DOM加载完成事件
$(document).ready(function(){
  您的代码...
});
//缩写
$(function($) {
  您的代码...
});


17、绑定事件
//bind 为每个匹配节点绑定事件处理函数，绑定多个用{}。
$("p").bind("click", function(){
  alert( $(this).text() );
});
$('#div1').bind({
    "mouseover":function () {
     $('#div1').parent().removeClass("hide");
     },"mouseout":function () {
     $('#div1').parent().addClass("hide");
}
});         

$("p").one( "click", function(){})    //事件绑定后只会执行一次
$("p").unbind( "click" )        //反绑一个事件

// 与bind 不同的是当时间发生时才去临时绑定。
$("p").delegate("click",function(){
  您的代码
});

$("p").undelegate();    　　　//p节点删除由 delegate() 方法添加的所有事件
$("p").undelegate("click")   //从p节点删除由 delegate() 方法添加的所有click事件

$("p").click();    　　//单击事件
$("p").dblclick();    //双击事件
$("input[type=text]").focus()  //节点获得焦点时,触发 focus 事件
$("input[type=text]").blur()   //节点失去焦点时,触发 blur事件
$("button").mousedown()//当按下鼠标时触发事件
$("button").mouseup()  //节点上放松鼠标按钮时触发事件
$("p").mousemove()     //当鼠标指针在指定的节点中移动时触发事件
$("p").mouseover()     //当鼠标指针位于节点上方时触发事件
$("p").mouseout()    　//当鼠标指针从节点上移开时触发事件
$(window).keydown()    //当键盘或按钮被按下时触发事件
$(window).keypress()   //当键盘或按钮被按下时触发事件,每输入一个字符都触发一次
$("input").keyup()     //当按钮被松开时触发事件
$(window).scroll()     //当用户滚动时触发事件
$(window).resize()     //当调整浏览器窗口的大小时触发事件
$("input[type='text']").change()    //当节点的值发生改变时触发事件
$("input").select()    //当input 节点中的文本被选择时触发事件
$("form").submit()     //当提交表单时触发事件
$(window).unload()     //用户离开页面时


18、事件对象
$("p").click(function(event){  
 alert(event.type); //"click"  
}); 

(evnet object)属性方法：
event.pageX 　 //事件发生时，鼠标距离网页左上角的水平距离
event.pageY 　 //事件发生时，鼠标距离网页左上角的垂直距离
event.type 　　//事件的类型
event.which 　 //按下了哪一个键
event.data 　　//在事件对象上绑定数据，然后传入事件处理函数
event.target 　//事件针对的网页节点
event.currentTarget  //可以监听哪个节点触发的事件.与target事件不同
event.preventDefault() 　//阻止事件的默认行为(比如点击链接，会自动打开新页面)
event.stopPropagation()  //停止事件向上层节点冒泡


19、动态事件绑定
 $("p").on("click",'span',function(){
alert( $(this).text() );
});
//当p中增加span时仍然有效


20、动画效果
$("p").show()    　　　　//显示隐藏的匹配节点
$("p").show("slow");    //参数表示速度,("slow","normal","fast"),也可为600毫秒
$("p").hide()    　　　　//隐藏显示的节点
$("p").toggle();   　　 //切换 显示/隐藏

$("p").slideDown("600");    //用600毫秒时间将段落滑下
$("p").slideUp("600");    　//用600毫秒时间将段落滑上
$("p").slideToggle("600");  //用600毫秒时间将段落滑上，滑下淡入淡出

$("p").fadeIn("600");    　　  //用600毫秒时间将段落淡入
$("p").fadeOut("600");    　　 //用600毫秒时间将段落淡出
$("p").fadeToggle("600");    　//用600毫秒时间将段落淡入,淡出
$("p").fadeTo("slow", 0.6);    //用600毫秒时间将段落的透明度调整到0.6
 

21、工具方法
$("#form1").serialize()    //序列表表格内容为字符串。
$("select, :radio").serializeArray();  //序列化表单元素为数组返回 JSON 数据结构数据
$.trim() 　　//去除字符串两端的空格
$.each() 　　//遍历一个数组或对象，for循环
$.inArray() //返回一个值在数组中的索引位置，不存在返回-1  
$.grep() 　 //返回数组中符合某种标准的节点
$.extend({a:1,b:2},{b:3,c:4},{c:5:d:6})  //将多个对象，合并到第一个对象{a:1,b:3,c:5,d:6}
$.makeArray() //将对象转化为数组
$.type()    //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等
$.isArray() //判断某个参数是否为数组
$.isEmptyObject() //判断某个对象是否为空(不含有任何属性)
$.isFunction()    //判断某个参数是否为函数
$.isPlainObject() //判断某个参数是否为用"{}"或"new Object"建立的对象
$.support()       //判断浏览器是否支持某个特性

22、AJAX
//保存数据到服务器，成功时显示信息
$.ajax({
   type: "POST",
   url: "some.php",
   data: "name=John&location=Boston",
   success: function(msg){
     alert( "Data Saved: " + msg );
   },
   error: function(err) {},
   complete: function(xhr, xhrstatus) {}  //无论成功失败都会执行
});

//加载 feeds.html 文件内容。
$("#feeds").load("feeds.html");

//请求 test.php 网页，传送2个参数，忽略返回值。
$.get("test.php", { name: "John", time: "2pm" } );

//从 Flickr JSONP API 载入 4 张最新的关于猫的图片。
$.getJSON("http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&tagmode=any&format
=json&jsoncallback=?", function(data){
  $.each(data.items, function(i,item){
    $("<img/>").attr("src", item.media.m).appendTo("#images");
    if ( i == 3 ) return false;
  });
});

//加载并执行 test.js ，成功后显示信息
$.getScript("test.js", function(){
  alert("Script loaded and executed.");
});

//向页面 test.php 发送数据，并输出结果（HTML 或 XML，取决于所返回的内容）：
$.post("test.php", { name: "John", time: "2pm" },
   function(data){
     alert("Data Loaded: " + data);
   });
   
//AJAX 请求完成时执行函数。
 $("#msg").ajaxComplete(function(event,request, settings){
   $(this).append("<li>请求完成.</li>");
 });
 
//AJAX 请求失败时显示信息。
$("#msg").ajaxError(function(event,request, settings){
     $(this).append("<li>出错页面:" + settings.url + "</li>");
});

//AJAX 请求发送前显示信息。
 $("#msg").ajaxSend(function(evt, request, settings){
   $(this).append("<li>开始请求: " + settings.url + "</li>");
 });
 
 //AJAX 请求开始时显示信息。
 $("#loading").ajaxStart(function(){
   $(this).show();
 });
 
//AJAX 请求结束后隐藏信息。
 $("#loading").ajaxStop(function(){
   $(this).hide();
 });
 
//当 AJAX 请求成功后显示消息。
 $("#msg").ajaxSuccess(function(evt, request, settings){
   $(this).append("<li>请求成功!</li>");
 });
 
//请求前过滤
$.ajaxPrefilter( function( options, originalOptions, jqXHR ) { 
   // Modify options, control originalOptions, store jqXHR, etc 
 });
 
 //设置全局 AJAX 默认选项，设置 AJAX 请求默认地址为 "/xmlhttp/"，禁止触发全局 AJAX 事件，用 POST 代替默认 GET 方法。其后的 AJAX 请求不再设置任何选项参数。
$.ajaxSetup({
  url: "/xmlhttp/",
  global: false,
  type: "POST"
});
$.ajax({ data: myData });

jsonp 的日常使用
$.ajax({
    url: 'http://www.aaaaa.com?appId=' + appIds + '&uId=' + uIds + '&from=' + froms + '&sign' + signs,
    type: "GET",
    dataType: "jsonp", 
    complete: function() {
        setTimeout(function(){
        if(successUrl){
            window.location.href=successUrl;
        }else if(commonSuccess == 1){
            window.location.href="/user/common/registerSuccess.html?activityName="+actName;
        }else{
            window.location.href="/user/regSuccess.html?activityName="+actName;
        }
        })
        regFlag=0;
    }
})




JavaScript中巧用位运算
日常前端开发中我们很少用到位运算，容易让人遗忘，让我们一起回顾下一下js中的位运算。
位运算详细说明查看JavaScript|MDN
下面主要回顾一下一些常用的位运算的巧用。
将十进制转化为二进制
var number = 3;
var result = number.toString(2);

var result2 = 14..toString(2); // "1110"


我们使用位运算来代替Math.floor()来向下取整
var data = 2.2352524535;
var result = data | 0; // 2


var re2 = ~~data; // 2

将颜色从RGA转换为Hex格式

var color = {r: 186, g: 218, b: 85};

// RGB to HEX
var rgb2hex = function(r, g, b) {
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).substr(1);
}
rgb2hex(color.r, color.g, color.b);//"#bada55"

区分两个数的大小
// variables
var a = 9285;
var b = 3569;

// 取大
var max = a ^ ((a ^ b) & -(a < b));//9285;

// 取小
var min =  b ^ ((a ^ b) & -(a < b);//3569

交换变量
var a = 10;
var b = 99;

a = (b^=a^=b)^a;

console.log(a) // 99
console.log(b) // 10

判断正负
function isPos(n) {
  return (n === (n >>> 0)) ? true : false;  
}
isPos(-1); // false
isPos(1); // true



js 阻止事件冒泡
    e.stopPropagation();
js阻止链接默认行为，没有停止冒泡
    e.preventDefault();
都阻止
    return false

停止jq中的ajax请求用abort()函数   


<html>  
<head>  
<mce:script type="text/javascript"><!--  
var currentAjax = null;  
function startAjax(){  
    //方法就是将XHR对象指向currentAjax，再调用currentAjax的.abort()来中止请求  
    currentAjax = $.ajax({  
           type:'POST',  
           beforeSend:function(){},  
           url:'test.php',  
           data:'username=xxx',  
           dataType:'JSON',  
           error:function(){alert('error')},  
           success:function(data){alert(data)}  
    });  
}  
function stopAjax(){  
    //如若上一次AJAX请求未完成，则中止请求  
    if(currentAjax) {currentAjax.abort();}  
}  
// --></mce:script>  
</head>  
<body>  
<input type="button" value="触发请求" onclick="startAjax()" />  
<input type="button" value="停止请求" onclick="stopAjax()" />  
</body>  
</html>  


single instanceof Object 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。

常用DOM指令
    Element 平时常用的div, span ,a就是element的一种，有这几种特性
        nodetype = 1;  nodeName为标签名  tagName也是标签名  nodeValue为null  parentNode可能是Document或element 子节点可能是 elemeht text comment processing_instruction ，CDATASection或EntityReference
    TEXT 表示节点文本 纯文本，不能包含html 但可以包含转义后的html代码 
        nodetype = 3 nodeNmae为 #text  nodeVlaue为文本内容   parentNode是一个Element   没有子节点
    Comment 表示文档注释  
        nodeType为8  nodeName为#comment  nodeValue为注释的内容 parentNode可能是Document或Element  没有子节点
    Document 表示文档 在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性
        nodeType为9    nodeName为#document    nodeValue为null   parentNode为null    子节点可能是一个DocumentType或Element
    DocumentFragment  能当作一个临时的仓库用来保存可能会添加到文档中的节点
        nodeType为11   nodeName为#document-fragment   nodeValue为null    parentNode为null

    createElement
        let element = document .createElement(tagName);   document.body.appendChild(elem);
    createTextNode      用来创建一个文本节点
    cloneNode  复制节点
        var dupNode = node.cloneNode(deep);   接受一个参数，表示是否要深复制子组件。  事件如果 是addEventListener 或onclick 则不会复制 ，如果是内联方式则会复制

    appendChild  xx.appendChild(child)   会在xx元素最后添加
    insertBefore
        parentNode.insertBefore(newNode,refNode);    parentNode为父节点    newNode为添加的新节点，   refNode为要参照节点
    replaceChild    替换节点
    removeChild     删除节点

http://www.open-open.com/lib/view/open1449325854077.html    移动端问题列表

 <!-- 设置缩放 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" />
  <!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 -->
  <meta name="format-detection"content="telephone=no, email=no" />

  其他meta标签
  <!-- 启用360浏览器的极速模式(webkit) -->
  <meta name="renderer" content="webkit">
  <!-- 避免IE使用兼容模式 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
  <meta name="HandheldFriendly" content="true">
  <!-- 微软的老式浏览器 -->
  <meta name="MobileOptimized" content="320">
  <!-- uc强制竖屏 -->
  <meta name="screen-orientation" content="portrait">
  <!-- QQ强制竖屏 -->
  <meta name="x5-orientation" content="portrait">
  <!-- UC强制全屏 -->
  <meta name="full-screen" content="yes">
  <!-- QQ强制全屏 -->
  <meta name="x5-fullscreen" content="true">
  <!-- UC应用模式 -->
  <meta name="browsermode" content="application">
  <!-- QQ应用模式 -->
  <meta name="x5-page-mode" content="app">
  <!-- windows phone 点击无高光 -->
  <meta name="msapplication-tap-highlight" content="no">

消除transition闪屏
    .css {
        -webkit-transform-style: preserve-3d;
        -webkit-backface-visibility: hidden;
        -webkit-perspective: 1000;
    }
    过渡动画（在没有启动硬件加速的情况下）会出现抖动的现象， 以上的 解决方案只是改变 视角 来启动硬件加速的一种方式；
    启动硬件加速的 另外一种方式： 
        .css {
            -webkit-transform: translate3d(0,0,0);
            -moz-transform: translate3d(0,0,0);
            -ms-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
        }
    
    启动硬件加速
    最常用的方式：translate3d、translateZ、transform

    opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）

    will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，
    其它属性并不会变成复合层），

    弊端： 硬件加速会导致 CPU性能占用量过大，电池电量消耗加大 ；因此 尽量避免泛滥使用硬件加速。

    translate3d 中如果使用百分比，他的值是相对于自身元素，而不是父级元素，并且在xyz的Z中使用百分比则会无效

  android 4.x bug
    1.三星 Galaxy S4中自带浏览器不支持border-radius缩写
    2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分
    3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色
    4.android无法同时播放多音频audio
    5.oppo 的border-radius 会失效

说明：移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。

    以下是历史原因，来源一个公司内一个同事的分享：
    2   007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。
    双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。
    原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接<a href="#"></a>，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。
    //解决方案：
    fastclick可以解决在手机上点击事件的300ms延迟
    zepto的touch模块，tap事件也是为了解决在click的延迟问题

// 运用HTML5的deviceMotion，调用重力感应事件
    if(window.DeviceMotionEvent){
        document.addEventListener('devicemotion', deviceMotionHandler, false)
    }   
    var speed = 30;
    var x = y = z = lastX = lastY = lastZ = 0;
    function deviceMotionHandler(eventData){
        var acceleration = event.accelerationIncludingGravity;
        x = acceleration.x;
        y = acceleration.y; 
        z = acceleration.z;
        if(Math.abs(x-lastX)>speed || Math.abs(y-lastY)>speed || Math.abs(z-lastZ)>speed ){
            //这里是摇动后要执行的方法 
            yaoAfter();
        }
        lastX = x;
        lastY = y;
        lastZ = z;
    }

    function yaoAfter(){
        //do something
    }

<!-- 播放视频不全屏
1.ios7+支持自动播放
2.支持Airplay的设备（如：音箱、Apple TV)播放
x-webkit-airplay="true" 
3.播放视频不全屏
webkit-playsinline="true" 
-->
<video x-webkit-airplay="true" webkit-playsinline="true" preload="auto" autoplay src="http://"></video>
https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement  video api
video | audio 在加载的时候会依次触发如下事件
    loadstart
    durationchange
    loadedmetadata
    loadeddata
    progress
    canplay
    canplaythrough



audio元素和video元素在ios和andriod中无法自动播放
    
    原因： 因为各大浏览器都为了节省流量，做出了优化，在用户没有行为动作时（交互）不予许自动播放；

    /音频，写法一
    <audio src="music/bg.mp3" autoplay loop controls>你的浏览器还不支持哦</audio>
    
    //音频，写法二
    <audio controls="controls"> 
        <source src="music/bg.ogg" type="audio/ogg"></source>
        <source src="music/bg.mp3" type="audio/mpeg"></source>
        优先播放音乐bg.ogg，不支持在播放bg.mp3
    </audio>
    https://www.jianshu.com/p/653a860b8dcb   //audio的各种方法以及各种事件效果的实现
    //JS绑定自动播放（操作window时，播放音乐）
    $(window).one('touchstart', function(){
        music.play();
    })
    
    //微信下兼容处理
    document.addEventListener("WeixinJSBridgeReady", function () {
        music.play();
    }, false);
    
    //小结
    //1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常；
    //2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间；
    //3.注意不要遗漏微信的兼容处理需要引用微信JS；

    <video id="hqb_3year_html5_api" class="vjs-tech" poster="/view/pages/activity/complex/threeYearH5/img/videoPoster.png" preload="auto" webkit-playsinline="true" playsinline="playsinline" x-webkit-airplay="true" x5-video-player-type="h5" x5-video-player-fullscreen="true" x5-video-ignore-metadata="true" style="object-fit: fill;" tabindex="-1" src="/view/pages/activity/complex/threeYearH5/img/video.mp4">
        <source src="/view/pages/activity/complex/threeYearH5/img/video.mp4" type="video/mp4">
        <source src="/view/pages/activity/complex/threeYearH5/img/video.webm" type="video/webm">
        <source src="/view/pages/activity/complex/threeYearH5/img/video.Ogg" type="video/ogg">
        <p class="vjs-no-js">
        抱歉，您的手机不支持视频文件<span id="J_skip">跳过</span>
        </p>
    </video>

    poster:  刚进入时的缩略图
    preload：是否预加载
    webkit-playsinline="true"  这个属性是ios 10中设置可以让视频在小窗内播放，也就是不是全屏播放*/  
    playsinline=true           IOS微信浏览器支持小窗内播放
    x-webkit-airplay="true"   不知道什么意思
    x5-video-player-type="h5"   启用H5播放器,是wechat安卓版特性
    x5-video-player-fullscreen="true"   全屏设置，设置为 true 是防止横屏
    x5-video-ignore-metadata="true"
    style="object-fit: fill;"  加这个style会让 Android / web 的视频在微信里的视频全屏，如果是在手机上预览，会让视频的封面同视频一样大小
    tabindex="-1"       允许tab键进行切换

css:
    行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？
    行内元素
        a、b、span、img、input、strong、select、label、em、button、textarea
    块级元素
        div、ul、li、dl、dt、dd、p、h1-h6、blockquote
    空元素
        即系没有内容的HTML元素，例如：br、meta、hr、link、input、img
    CSS中居中的几种方式
        - 块级居中(block)： margin: 0 auto
        - 行级居中（inline,inline-block）父元素css：text-align: center
        - 定位水平垂直居中：left：50%;top:50%;margin-left:负自身宽度的一半;margin-top:负自身高度的一半;
        - 定位水平垂直居中：top:0;bottom:0;left:0;right:0;margin:auto;
        - css3+定位水平垂直居中：left：50%;top:50%;transfrom:(-50%,-50%);
        - 水平垂直居中：diplay：table-cell;vertical-align: middle;
        - 水平垂直居中：flexBox居中 display: flex;justify-content: center;align-items:center;
        - 水平垂直居中：vertical-align:middle;
         让div出现滚动条     overflow-y: auto;
         user-select: none    让文字不能被选中（2017.8.8写分页插件时需要双击时文字不被选中）
         行内元素使用了dispaly: inline-block 之后要使用 vertical-align: top;  会出现下移的情况
         letter-spacing   字间距
         pre 标签设置自动换行 white-space: pre-wrap;
         user-select: none; // 禁止文字被选中
        outline:none; // 去除点击外边框,点击无轮廓
        -webkit-touch-callout: none; // 长按链接不弹出菜单
        -webkit-tap-highlight-color: rgba(0,0,0,0); // 去除点击高亮
        鼠标禁用 .disabled { pointer-events: none; }
css实现单行文本溢出显示 ...
    overflow: hidden;
    text-overflow:ellipsis;
    white-space: nowrap;
    当然还需要加宽度width属来兼容部分浏览。
实现多行文本溢出显示...
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
  overflow: hidden;
让图文不可复制
  -webkit-user-select: none; 
  -ms-user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  user-select: none;
    媒体查询iphone4 (注: 查询样式应该写到原样式的后面,这样才不会被外面的替换掉)
    @media screen and (device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2){}
    媒体查询iphone5
    @media screen and (device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2){}
    /* 判断ipad */
    @media only screen and (min-device-width : 768px) and (max-device-width : 1024px){}
    /* ipad横屏 */ 
    @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape){}
    /* ipad竖屏 */
    @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait){}
    选择器
        E:nth-last-child(n)     从最后开始的第N个元素
        E:nth-of-type(n)        从头开始的第N个元素
        E:nth-last-of-type(n) 
        E:last-child 
        E:first-of-type 
        E:only-child 
        E:only-of-type 
        E:empty 
        E:checked 
        E:enabled 
        E:disabled 
        E::selection 
        E:not(s)
    文字渲染
        Text-decoration
        Text-fill-color: 文字内部填充颜色
        Text-stroke-color: 文字边界填充颜色
        Text-stroke-width: 文字边界宽度
    多列布局
    .multi_column_style{ 
        -webkit-column-count: 3; 
        -webkit-column-rule: 1px solid #bbb; 
       -webkit-column-gap: 2em; 
    }
    阴影
        box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
    渐变效果
        background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E));
    径向渐变
        backgroud: -webkit-gradient(radial,50 50,50,50 50,0,from(black),color-stop(0.5,red),to(blue));
    返射效果
        .classReflect{ 
            -webkit-box-reflect: below 10px 
            -webkit-gradient(linear, left top, left bottom, from(transparent), 
            to(rgba(255, 255, 255, 0.51))); 
        }
    transition  //css过渡
        transition-property     //规定设置过渡效果的 CSS 属性的名称。 none|all|property;
        transition-duration     //规定完成过渡效果需要多少秒或毫秒。   time
        transition-timing-function      //规定速度效果的速度曲线。
        linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);
        linear   //规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。
        ease    //规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。
        ease-in //规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。
        ease-out    //规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。
        ease-in-out     //规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。
        cubic-bezier(n,n,n,n)   //在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。
        transition-delay        //定义过渡效果何时开始。 time
        //http://cubic-bezier.com/#.22,.89,.95,.04   自己定义贝塞尔曲线的网站
        // transition: width 2s, height 2s, transform 2s;       demo
    transform   //变化 css变形 
        常用属性  translate  位移,   scale 缩放,s   rotate 旋转
    animation   //动画
        animation-name      //规定需要绑定到选择器的 keyframe 名称。。
        animation-duration      //规定完成动画所花费的时间，以秒或毫秒计。
        animation-timing-function       //规定动画的速度曲线。
        animation-delay     //规定在动画开始之前的延迟。
        animation-iteration-count       //规定动画应该播放的次数。
        animation-direction     //规定是否应该轮流反向播放动画。
        animation-play-state    //paused  running  暂停 启动
        animation-fill-mode     定义动画完成之后停留在最后  
    http://www.w3school.com.cn/css3/css3_animation.asp
    demo: 
        // @keyframes myfirst
        // {
        //     from {background: red;}
        //     to {background: yellow;}
        // }
        // @-webkit-keyframes myfirst /* Safari 与 Chrome */
        // {
        //     from {background: red;}
        //     to {background: yellow;}
        // }
        // div
        // {
        //     animation: myfirst 5s;
        //     -webkit-animation: myfirst 5s; /* Safari 与 Chrome */
        // }
    flex：
        .外面的容器
            display: flex;
            flex-direction: row;        //伸缩流方向: 水平方向row | 反向水平row-reverse | 垂直方向column | 反向垂直column-reverse
            flex-wrap: wrap;            //溢出时是否换行    不换行nowrap | 换行wrap  | 反转换行wrap-reverse
            justify-content: space-between;    //主轴对齐方式: 左对齐flex-start | 居中对齐center | 右对齐flex-end | 两端对齐space-between | 扩散对齐space-around
            align-items: center;       //侧轴对齐方式: 顶边对齐flex-start | 中间对齐center  | 底部对齐flex-end | 基线对齐baseline | 伸缩项目拉伸填充整个伸缩容器stretch
            align-content: center;     //侧轴多个对齐方式: 顶边对齐flex-start | 中间对齐center  | 底部对齐flex-end | 两端对齐space-between  | 扩散对齐space-around | 伸缩项目拉伸填充整个伸缩容器stretch
        .里面的容器
            align-self: auto[默认]     //侧轴对齐方式: 自动auto | 顶边对齐flex-start | 中间对齐center | 底部对齐flex-end | 基线对齐baseline | 伸缩项目拉伸填充整个伸缩容器stretch
            flex-basis: <length> | auto[默认]  //伸缩项目在主轴方向上的初始大小
            order: <number>[默认为0]       //显示顺序: 定义伸缩项目的排列顺序，数值越小，排列越靠前
            flex: none | [<flex-grow> <flex-shrink>? || <flex-basis>]
                flex: none => flex: 0 0 auto;//表示宽度为原始宽度，不发生扩展或收缩
                flex: auto => flex: 1 1 auto;//表示除了占据原先的宽度外，还要分配剩余宽度(包括扩展或收缩)
                flex: 0 => flex: 0 1 0%;//表示收缩为最小宽度
                flex: 1 => flex: 1 1 0%;//表示分配所有宽度(包括扩展或收缩)
                flex: 0 auto => flex: 0 1 auto;(默认值)//表除了占据原先的宽度外，还要分配剩余宽度(只收缩，不扩展)
                flex: 0 1 => flex: 0 1 0%;

xhr  xmlhttprequest 使用
    1. var xhr = new XMLHttpRequest();
    open
        这个方法必须在实际发送请求之前调用,用来验证请求方法,url,以及用户信息
        可以接受5个参数
        open( Method, URL, Asynchronous, UserName, Password )
            method:  请求的方法,  get/post,
            url: 请求的url
            Asynchronous： 是否是异步上传 默认是true
            username, password 是用户名密码
    sendRequestHeader
        在成功初始化请求之后，XMLHttpRequest对象的setRequestHeader方法可以用来设置请求头。
        setRequestHeader( Name, Value )
        第一个参数是header的字符串名称，第二个参数是字符串值。如果请求需要多个header，这个方法就要被调用多次。这个方法附加的请求头，在下次open方法调用时会被清空。
    send
        用来发送请求，这个方法接收一个参数，这个参数就是要发送的内容。
        send(Data)
    onreadystatechange事件监听器
        状态改变过程如下：
        当open方法被成功调用，readyState属性被置为1(OPEND)
        当send方法被调用，成功接收到HTTP响应头，readyState属性被置为2(HEADERS_RECEIVED)
        一旦HTTP响应内容开始加载，readyState属性被置为3(LOADING)
        一旦HTTP响应内容结束加载，readyState属性被置为4(DONE)
        当监听器被定义之后，每次状态改变时都会触发。为了检测状态1和状态2，监听器必须在open方法调用前调用。open方法必须在send方法调用前调用。
    abort方法
        如果XMLHttpRequest对象的readyState属性还没有变成4，这个方法可以终止请求。这个方法可以确保异步请求中的回调不被执行。

    比较冷门的方法
        //设置xhr请求的超时时间
        xhr.timeout = 3000;
        //设置响应返回的数据格式
        xhr.responseType = "json";
    在xhr2.0中还引入了
        xhr.onload  === onreadystatechange
        xhr.onerror
        CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，需要
        xhr.withCredentials = true;  
        (如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名)

    正确的使用方法是
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
            if(xhr.readyState !== 4) {return}
            if((status >= 200 && status < 300) || status === 304) {}
            执行options传过来的success方法
        }
        xhr.open('get', 'www.baidu.com');
        xhr.sendRequestHeader("Content-Type","application/x-www-form-urlencoded");
        xhr.send(options.data)
    以上是一个完整的流程

formData            https://segmentfault.com/a/1190000012327982
    1.formData主要用一些键值对来模拟一系列的表单控件,即把form中所有的表单元素的name与value组装成一个querystring
    2.异步上传文件
    3.formData的使用
        let formData = new FormData()
        formData.append('user', 'zhang')
        获取 formData.get('user')  //zhang
        删除 formData.delete('user')
    4.new FormData的参数是一个DOM对象，而非jQuery对象
        var formData = new FormData($("#file")[0]);
    5.序列表表格内容为字符串，用于 Ajax 请求。 jquery 语法
        $("form").serialize()


canvas, dataurl, file, blob 对象之间的相互转换      https://blog.csdn.net/cuixiping/article/details/45932793
    1.canvas转换为dataURL (从canvas获取dataURL)
        var dataurl = canvas.toDataURL('image/png');
        var dataurl2 = canvas.toDataURL('image/jpeg', 0.8);
    2.File对象转换为dataURL、Blob对象转换为dataURL
        window.URL.createObjectURL(file)  好像这种效果更加方便
            or
        function readBlobAsDataURL(blob, callback) {
            var a = new FileReader();
            a.onload = function(e) {callback(e.target.result);};
            a.readAsDataURL(blob);
        }
        readBlobAsDataURL(blob, function (dataurl){
            console.log(dataurl);
        });
        readBlobAsDataURL(file, function (dataurl){
            console.log(dataurl);
        });
    3.dataURL转换为Blob对象、dataURL转换为File对象
        function dataURLtoBlob(dataurl) {
            var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], {type:mime});
        }
        function dataURLtoFile(dataurl, filename) {
            var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new File([u8arr], filename, {type:mime});
        }
        var blob = dataURLtoBlob('data:text/plain;base64,YWFhYWFhYQ==');
        var file = dataURLtoFile('data:text/plain;base64,YWFhYWFhYQ==', 'test.txt');
    4.dataURL图片数据绘制到canvas
        var img = new Image();
        img.onload = function(){
            canvas.drawImage(img);
        };
        img.src = dataurl;
    5.File,Blob的图片文件数据绘制到canvasFile,Blob的图片文件数据绘制到canvas
        readBlobAsDataURL(file, function (dataurl){
            var img = new Image();
            img.onload = function(){
                canvas.drawImage(img);
            };
            img.src = dataurl;
        });
HTML5文件拖放   拖拽：Drag    释放：Drop
    1.在一个元素中添加  draggable='true' 则可以设置这个元素为可拖放元素
        dataTransfer.setData() 方法设置被拖动数据的数据类型和值：
        function drag(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
        }
        数据类型是 "text"，而值是这个可拖动元素的 id ("drag1")。
    2.设置元素被拖动时触发的事件 ondragstart      <label draggable="true" ondragstart="drag(event)">...</label>
    3.ondragover 事件规定被拖动的数据能够被放置到何处。
    4.ondrop  当放开被拖数据时，会发生 drop 事件。

    源对象：
        dragstart：源对象开始拖放。
        drag：源对象拖放过程中。
        dragend：源对象拖放结束。
    过程对象：
        dragenter：源对象开始进入过程对象范围内。
        dragover：源对象在过程对象范围内移动。
        dragleave：源对象离开过程对象的范围。
    目标对象：
        drop：源对象被拖放到目标对象内。


ES6:
    变量结构赋值
        let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
        如果要把值定义成不是对象中的属性的名字的话，可以这样使用，在react中比如说要把这个值变成component, 第一个字母要大写，可以使用这种方法
    class
        class 必定会有一个constructor方法.  constructor默认返回this    constructor也算是实例prototype中的一个属性
        在new 这个实例的时候，会自动执行一次constructor  例子 
            class print {
                constructor(x, y) { 
                    this.x = x;
                    this.y = y;
                }
            }
            var aa = new print(2,5);   此时会执行一次 aa.constructor === print   
        继承的时候需要 super()  一次,  super() 相当于是执行一次 print.prototype.constructor.call(this);  从而返回的是自身的实例,  并且是继承了父组件中的constructor中的属性
        es5中的继承 
            function Super() {}
            function Sub() {}
            Sub.prototype = new Super();
            Sub.prototype.constructor = Sub;
            var sub = new Sub();

        class A {}
        class B extend A {} 
        es6 class 中 子类的的__proto__ 指向 A    子类的prototype的__proto__指向父类的prototype    B.prototype.__proto__ === A.prototype 
        
    修饰器 Decorator @ 的使用
        1.主要分为三种,一种是对类的使用 class
            @types
            class aa {}
            function types(target) {}
            这样使用的时候 types 带一个target参数，是指向这个被修饰的类,  可以在这个类里添加属性
        2.在类的原型中使用 prototype
            class aa{
                @types
                add(){}
            }
            function types(target, name, descriptor)
            接收三个参数，分别是类的原型 也就是 aa.prototype, name 就是要修饰的属性名， 也就是add , descriptor 是该属性的描述对象 
            // descriptor对象原来的值如下
            {
                value: specifiedFunction,
                enumerable: false,
                configurable: true,
                ritable: true
            };
            最后return descriptor

VUE
    var app = new Vue({
        el: '#app',
        data: {
            message : "xuxiao is boy" 
        },
        beforeCreate: function () {
                console.group('beforeCreate 创建前状态===============》');
                console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined
                console.log("%c%s", "color:red","data   : " + this.$data); //undefined 
                console.log("%c%s", "color:red","message: " + this.message)  
        },
        created: function () {
            console.group('created 创建完毕状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el); //undefined
                console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化 
                console.log("%c%s", "color:red","message: " + this.message); //已被初始化
        },
        beforeMount: function () {
            console.group('beforeMount 挂载前状态===============》');
            console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化
            console.log(this.$el);
                console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化  
                console.log("%c%s", "color:red","message: " + this.message); //已被初始化  
        },
        mounted: function () {
            console.group('mounted 挂载结束状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化
            console.log(this.$el);    
                console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化
                console.log("%c%s", "color:red","message: " + this.message); //已被初始化 
        },
        beforeUpdate: function () {
            console.group('beforeUpdate 更新前状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);   
                console.log("%c%s", "color:red","data   : " + this.$data); 
                console.log("%c%s", "color:red","message: " + this.message); 
        },
        updated: function () {
            console.group('updated 更新完成状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el); 
                console.log("%c%s", "color:red","data   : " + this.$data); 
                console.log("%c%s", "color:red","message: " + this.message); 
        },
        beforeDestroy: function () {
            console.group('beforeDestroy 销毁前状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);    
                console.log("%c%s", "color:red","data   : " + this.$data); 
                console.log("%c%s", "color:red","message: " + this.message); 
        },
        destroyed: function () {
            console.group('destroyed 销毁完成状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);  
                console.log("%c%s", "color:red","data   : " + this.$data); 
                console.log("%c%s", "color:red","message: " + this.message)
        }
    })

    VUE-自定义指令      https://cn.vuejs.org/v2/guide/custom-directive.html
    //自定义组件钩子  bind  inserted   update   componentUpdated   unbind
    //  bind初始化的时候传入参数  el 指令所绑定的元素，可以用来直接操作 DOM   
    //  binding 一个对象，包含以下属  name 指令名，不包含v-    value指令绑定的值  v-model='ff'  绑定值为ff
    //          oldValue 绑定的前一个值     expression  字符串形式的指令表达式 v-my-directive="1 + 1"  中，表达式为 "1 + 1"
    //          arg 传给指令的参数    modifiers 一个包含修饰符的对象
    //  vnode：Vue 编译生成的虚拟节点
    //  oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

    Vue常用的三种传值方法、
        1.父组件传子组件   props
        2.子组件传父组件   this.$emit(aa,  ang);       v-on:aa="xxx"
        3.兄弟组件传值    bus.js
            import Vue from 'vue'
            export default new Vue()
            A： Bus.$emit('val', this.elementValue)
            B： Bus.$on('val', (data) => { console.log(data) vm.name = data })

    vue router 路由
        1.全局守卫:
            router.beforeEach 全局前置守卫 进入路由之前
            router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用
            router.afterEach 全局后置钩子 进入路由之后
            to,from,next 这三个参数：
            to和from是将要进入和将要离开的路由对象,路由对象指的是平时通过this.$route获取到的路由对象。
            next:Function 这个参数是个函数，且必须调用，否则不能进入路由(页面空白)。
            import router from './router'; // 引入路由
            router.beforeEach((to, from, next) => { 
                next();
            });
            router.beforeResolve((to, from, next) => {
                next();
            });
            router.afterEach((to, from) => {
                console.log('afterEach 全局后置钩子');
            });
        2.单独页面配置
            const router = new VueRouter({
                routes: [
                    {
                    path: '/foo',
                    component: Foo,
                    beforeEnter: (to, from, next) => { 
                        // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖
                        // ...
                    }
                    }
                ]
            })
            beforeRouteEnter (to, from, next) {
                // 在路由独享守卫后调用 不！能！获取组件实例 `this`，组件实例还没被创建
                console.log('在路由独享守卫后调用');
                next(vm => {
                    // 通过 `vm` 访问组件实例`this` 执行回调的时机在mounted后面，
                })
            },
            beforeRouteUpdate (to, from, next) {
                // 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 `this`
                // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
                // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
            },
            beforeRouteLeave (to, from, next) {
                // 导航离开该组件的对应路由时调用，可以访问组件实例 `this`
            }
    路由缓存
        <keep-alive>
            <router-view></router-view>
        </keeo-alive>
    Vue.extend
    Vue.component: 将一个组件构造成一个全局组件,(可以是Vue.extend的的实例，也可以是普通组件，会自动执行extend) ;
        Vue.component('component-one', xxxx);    new Vue({el: '#app'});  直接在子组件中使用即可   一般在model中使用

    <route-view></route-view>  组件中如果设置了name属性, 在router中的children中的component要是object components: {name: xxx};
    要入传入的name一致才会显示，否则不会渲染。
    
    https://segmentfault.com/a/1190000011057149  EXCEL 导出
    http://element-cn.eleme.io/#/zh-CN/component/installation  element-ui 官网


react 状态管理 实例化
首次实例化
    getDefaultProps
    getInitialState
    componentWillMount
    render
    componentDidMount
存在期
组件已经存在，状态发生改变时
    componentWillReceiveProps
    shouldComponentUpdate
    ComponentWillUpdate
    render
    componentDidUpdate
    简单记忆：receiveProps => shouldUpdate => update => render => updated
销毁期 
    componentWillUnmount

detDefaultProps 作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享
getInitialState 作用于组件实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props
componentWillMount 在完成首次渲染之前调用，此时可以修改组件的state
render 必选方法，创建虚拟DOM，该方法具有特殊规则：
    只能通过this.props 和this.state访问数据
    可以返回null、false或任何React组件
    只能出现一个顶级组件，数组不可以
    不能改变组件的状态
    不能修改DOM
componentDidMount 真实的DOM被渲染出来后调用，可以在此方法中通过 this.getDOMNode()访问真实的DOM元素。此时可以使用其它类库操作DOM。服务端不会被调用
componentWillReceiveProps 组件在接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件的props及state
shouldComponentUpdate 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用性能瓶颈时，是一个可以优化的点。
componentWillUpdate 接收新props或state后，进行渲染之前调用，此时不允许更新props或state
componentDidUpdate 完成渲染新的props或state之后调用 ，此时可以访问DOM元素。
componentWillUnmount 组件被移除之前调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。

react新建组件分别react.createClass 与 React.Component
    使用React.createClass创建时, 每一个成员的this都会被react自动绑定  在 React.Componet的时候需要手动绑定一次
    React.Component开发组件是一般有四种方法绑定
    1. class re extend React.Component {
        constructor(props) {super(props)}
        haclick() {}
        render() {
            return (<div onClick={this.haclick.bind(this)}></div>)
        }
    }
    2. class re extend React.Component {
        constructor(props) {super(props)  this.haclick= this.haclick.bind(this)}
        haclick() {}
        render() {
            return (<div onClick={this.haclick}></div>)
        }
    }
    3. class re extend React.Component {
        constructor(props) {super(props) }
        haclick = () => {}
        render() {
            return (<div onClick={this.haclick}></div>)
        }
    }
    如果不绑定this; 执行haclick方法时,实际上执行的是原型方法;可这样看起来并没有什么影响，如果当前组件的构造器中初始化了state这个属那么原型方法执行时，this.state会直接获取实例的state属性，
    如果构造其中没有初始化state这个属性（比如React中的UI组件），说明组件没有自身状态，此时即使调用原型方法似乎也没什么影响。
    http://www.cnblogs.com/dashnowords/p/9343383.html

getDerivedStateFromProps

https://juejin.im/post/59eb03b86fb9a0451049a0ae

当组件发生更新时，组件的生命周期方法的调用顺序如下:
    componentWillReceiveProps -> shouldComponentUpdate -> componentWillUpdate -> render -> componentDidUpdate
    // 组件收到新的props（props中的数据并不一定真正发生变化）-> 决定是否需要继续执行更新过程 -> 组件代表的虚拟DOM即将更新 -> 组件重新计算出新的虚拟DOM -> 虚拟DOM对应的真实DOM更新到真实DOM树中
组件自身调用setState，导致的组件更新，其生命周期方法的调用情况如下：
shouldComponentUpdate -> componentWillUpdate -> render -> componentDidUpdate

react-router 4.x 权限控制地址  https://reacttraining.com/react-router/web/example/auth-workflow

react 进阶之路                                 https://juejin.im/post/5ae2b5b851882567161a4af6
react-copy-to-clipboard   react 复制文本插件   https://github.com/nkbt/react-copy-to-clipboard
react 图片裁剪                                   https://github.com/jerryshew/react-image-cropper
react 图片上传  可轮子                          https://github.com/jerryshew/react-file-upload
immutable-js   对于优化代码很有用，正在学习中    https://github.com/chrisvfritz/prerender-spa-plugin

https://mobile.ant.design/components/progress-cn/       react antd-mobile 

create-react-app 安装使用
    npm install -g create-react-app
    create-react-app my-app
    cd my-app
    npm run start

    修改端口号: 在node_modules文件夹里面react-scripts，看到scripts文件夹。在start.js里面找到端口号并修改
    增加接口代理： "proxy":"http://localhost:8000",  在package.json,里面添加

使用typescript
create-react-app my-app --scripts-version=react-scripts-ts

https://github.com/jimwmg/JiM-Blog/tree/master/React/React%E5%9F%BA%E7%A1%80            很有用的源码分析资料   主要学习这一块
https://elemefe.github.io/element-react/#/zh-CN/quick-start  element-ui-react 地址

base64解码
atob(decodeURIComponent('MTMzMzI4MzA0MTM%3D'));


typescript 入门备注
1. let isDone: boolean = false;   布尔类型
2. let decLiteral: number = 6;  数字
3. let name: string = "bob";   字符串
4. let list: number[] = [1,2,3]     let list: Array<number> = [1,2,3]  数组

element.clientTop  等dom元素属性操作时, 需要 (xxx as HTMLElement).clientHeight;

public 公有 任何人可以访问
private 私有 只有类内部可以访问
protected 受保护 只有子类能用

install typescript -g 之后，可以使用tsc 来进行编译, 编译文件是根据tsconfig.json 来判断,
在本地调试typescript 使用 ts-node 来启动
在node中使用typescript 出现 2034 not find require 的时候，需要安装一个@type/node 插件, 但是还是统一为好


https://regex101.com/r/7g1JSQ/1   正则在线验证

nodejs
    https://github.com/ijse/freemarker.js     nodejs中渲染使用java的 freemarker.js
    全局变量:
        __dirname:   指向的是当前文件目录的绝对路径   例如:  src/components/login/index.jsx  指向的是 E:/pro/react/src/components/login


react 谷歌调试


js继承
    https://segmentfault.com/a/1190000015727237?utm_source=tag-newest
    1.原型式继承
        function superType() {}
        function super() {}
        super.prototype = new superType()
        super.prototype.constructor = super; //所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。
    2.构造函数继承
        superType.call(super);
    3.组合继承
        function SuperType() {this.name = 'parent';this.arr = [1, 2, 3];}
        SuperType.prototype.say = function() { console.log('this is parent')}
        function SubType() {SuperType.call(this) // 第二次调用SuperType}
        SubType.prototype = new SuperType() // 第一次调用SuperType
    4.原型式继承
        function object(o){
            function F(){}
            F.prototype = o;
            return new F();
        }
        var person = {
            name: "Nicholas",
            friends: ["Shelby", "Court", "Van"]
        };
        var anotherPerson = object(person);
        anotherPerson.name = "Greg";
        anotherPerson.friends.push("Rob");

        var yetAnotherPerson = object(person);
        yetAnotherPerson.name = "Linda";
        yetAnotherPerson.friends.push("Barbie");
        alert(person.friends);   //"Shelby,Court,Van,Rob,Barbie"
    5.寄生组合继承
        function object(o){
            function F(){}
            F.prototype = o;
            return new F();
        }
        function inheritPrototype(subType, superType) {
            var proto = object(superType.prototype)
            proto.constructor = subType
            subType.prototype = subType
        }
        function SuperType(name){
            this.name = name;
            this.colors = ["red", "blue", "green"];
        }

        SuperType.prototype.sayName = function(){
            alert(this.name);
        };

        function SubType(name, age){
            SuperType.call(this, name);
            this.age = age;
        }
        SubType.prototype.sayAge = function(){
            alert(this.age);
        }
        inheritPrototype(SubType, SuperType);


js对象分为  普通对象 跟  函数对象

constructor  指向的是 构造函数
比如说   function aa() {this.name = 22};   var bb = new aa();   var cc = new aa();
这时候  bb cc都是 aa 的实例  每一个实例都有一个 constructor , 这个属性是指向 aa;
console.log(bb.constructor == aa); //true      
记住名词  aa  是 构造函数    bb  cc是实例   实例的构造函数属性（constructor）指向构造函数。


2. prototype  
    每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性
    aa.prototype = {
        name: 2,
        age: 3
    }
    在默认情况下，所有原型对象都会有一个constructor， 指向的是 aa
    类似  bb.constructor === aa;       aa.prototype.constructor === aa 一样，
    也可以理解为 ，aa.prototype 是 aa 的实例，也就是在函数对象生成的时候
    会自动在prototype中执行了一次   aa.property = new aa();

可以得出结论  原型对象（Person.prototype）是 构造函数（Person）的一个实例。

3. __proto__
 所有对象都有一个proto  指向的是 创建他的构造函数（aa）的原型对象（prototype）


var a = {}  ===   var a = new Object();    所以a.constructor === Object   a.__proto__ = Object.prototype;    Object.prototype.constructor = Object  

new() 做了些什么？

var obj = new Base();
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);

AMD CMD  ES6 Module
1.CMD是平常NODE使用的,也是使用rquire('..')引入，暴露模块的话是  exports.module   CMD是同步的。需要等上面的加载完成才能够执行
2.AMD常见的是requier.js, 是有二个参数的 require('define', callback);  在暴露的时候需要使用define封装一层。
3.ES6  引入是使用import 直接引。  暴露是export xxx  或者默认模块是  export default

ES6 Module 引用 CMD;   如果moudle.exports是一个函数,则要使用 import * as React from 'react';  如果module.export是一个object 则使用 import foo from './foo'  var f = foo.default = {} 就是取到 module.exports

CMD每一个模块都会生成一个modules  exports是modules中的一个属性。 exports 其实就是 module.exports = {}  CMD 导出是 exports.aa = aa;  也可以 module.exports = {aa: {}, bb: {}}

Decorator  ES7 装饰器
ES7的Decorator语法类似于Python中的Decorator，在ES7中也仅仅只是一个语法糖，@decorator主要有两种，一种是面向于类(class)的@decorator，另一种是面向于方法(function)的@decorator。并且@decorator实质是利用了ES5中的Object.defineProperty


git 第一步

git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/miaomiaodaren/KoaAdmin.git
git push -u origin master
git log     查看提交的历史记录    -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交
git add    把文件修改提交到 暂存区
git commit 把文件提交到本地仓库，可以使用push再提交到线上
git status 查看有哪些还没提交
git push   git push <远程主机名> <本地分支名>:<远程分支名>
git add    git add . 将所有修改添加到暂存区
git reset  把add的文件还原掉 
git clone xx.git    把远程仓库中的代码复制到本地仓库中
git remote -v  查看连接了哪些远程分支， 以及名字
git remote rm [name] 删除远程分支   

git it stash save "test-cmd-stash"   用于把本地的代码先暂存到,  在pull远程代码冲突时需要这样做
git stash pop stash@{0}    还原暂存的东西  也可以使用 apply <-> pop  用来多次使用
git stash list      查看暂存的列表


https://github.com/noahlam/Miment/blob/master/src/miment.js    //类似moment的的一个日期插件
https://motion.ant.design/language/basic            react 动效网站 

通过vue or react 在写model弹出框时，需要考虑的问题
    1.zindex的自增长问题。   https://github.com/ElemeFE/vue-popup/blob/master/src/popup-manager.js
    参考此网站，定了一个变量。其后写了一个方法。让其xx++,自增加，当刷新时重置


mongoose
    Schema中所支持的数据类型有：String, Number, Date, Buffer, Boolean, Mixed, Objectid, Array

webpack
    1.在webpack单页中使用less or sass 的全局变量
    {
        loader: 'sass-resources-loader',
        options: { resources: [ 
            path.join(__dirname, '../../../src/static/css/main.less'),
        ]}
    }
    引入此Loader,(注: 全局的less只能放全局变量,否则会造成大量冗余.)
    2.在打包之后的html中,对文件进行一些操作
        新建一个文件
            function insertHtmlCode(options) {
                this.options = options
            }
            insertHtmlCode.prototype.apply = function(compiler) {
            var source = this.options.source,
                target = this.options.target
            compiler.plugin('compilation', function(compilation) {
                compilation.plugin('html-webpack-plugin-after-html-processing', function(htmlPluginData, callback) {
                htmlPluginData.html = htmlPluginData.html.toString().replace(source,target)
                callback()
                });
            });
            };
            module.exports = insertHtmlCode;
        在webpack.pro.conf.js的plugin中使用
            new insertHtmlCode({
                source:'<input type="hidden" id="access_token" value="">',
                target:'<#if session_user?exists><input type="hidden" id="access_token" value="${session_user.oauth_token}"><#else><input type="hidden" id="access_token"></#if>'
            })

DOM原生
    1.tab切换  ----------------------  完成
    2.数字滚动增加 -------------------  完成
    3.图片轮播  ---------------------  
    4.日历 --------------------------  
    5.五星评分 ----------------------
    6.左右可手动穿梭框  --------------
    7.左右滑动手势 ------------------ 
    8.model弹窗 -------------------- 


https://segmentfault.com/a/1190000014683917         用 ES6 写全屏滚动插件

npm 显示所有可以升级的包列表   安装 npm install npm-check -g  然后  npm-check -u -g
npm 安装当前插件的最新版本  npm instll axios@latest --save
npm 全局删除包   npm uninstall -g xxxx


网易云音乐歌词
    http://music.163.com/api/song/media?id=109751
    http://lxgandlz.cn/459.html   //歌词同步教程
    https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%E8%8E%B7%E5%8F%96%E9%9F%B3%E4%B9%90-url  网易云音乐API接口文档

678293  服务器密码  
http://47.96.114.115  服务器地址
root   fy5201314*
项目地址   /usr/local/src/

shutdown -r now   立即重启
./mongod -f mongodb.conf  连接mongodb数据库
db.createUser({user: 'root', pwd: '123456', roles: ["root"]})
db.createUser({user: 'nodejs', pwd: '123456', roles: [{role: 'userAdmin', db: "nodejs"}]})
db.createUser({user: "admin", pwd: 'admin', roles: [{role: "userAdmin",db: "admin"}]})

use admin
db.shutdownServer()  关闭mongodb数据库

netstat -tunlp		//查看端口使用情况
使用npm全局安装之后。需要这样ln一下
sudo ln -s /root/node-v8.11.2-linux-x64/lib/node_modules/pm2/bin/pm2 /usr/bin/pm2   文件夹移动
systemctl stop firewalld		//关闭当前防火墙
systemctl disable  firewalld	//开机自动关闭防火墙
curl localhost:3003				//在linux系统中访问这个端口


linux nginx 使用
	killall -9 nginx   删除nginx
	ps aux|grep nginx  查看是否启动nginx
	/usr/local/nginx/sbin/nginx  启动nginx
	/usr/local/nginx/conf/		设置nginx地址
	
pm2 使用
pm2 list   查看当前启动的列表
pm2 restart all  重启所有的项目
pm2 delete all  删除PM2列表中所有的进程
pm2 start app.js --watch   #实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动reloa


Electron
    桌面应用开发

angular
    ionic  开发框架

react native  
    C:\Users\fufeng\Downloads\android-sdk_r24.4.1-windows\android-sdk-windows
react native 入门教程
    1.安装Chocolatey   cmd进入  @powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" && SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin
    2.安装ptyhon2   choco install python2
    android sdk 下载地址 http://tools.android-studio.org/index.php/sdk
    adb devices
    adb connect 127.0.0.1:5555          //连接模拟器

    npm start -- --reset-cache
    react-native run-android

    错误列表
        unable to load script form assets 
            在 android/app/src/main 目录下创建一个 assets空文件夹
            在项目根目录运行
            react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/
        SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable.
            android下新建local.properties
            sdk.dir = C:/Users/fufeng/Downloads/android-sdk_r24.4.1-windows/android-sdk-windows
        Unable to resolve module AccessibilityInfo from XXX 是因为版本问题
            https://blog.csdn.net/j550341130/article/details/81027700

高德地图接口平台    地图轨迹回放
    https://lbs.amap.com/api/javascript-api/example/marker/replaying-historical-running-data/   


微信公众号 
    帐号： tsjw51042562163.com
    AppID:   wxc17275a872d36e36
    AppSecret:   726b75ce07554990ec124f31b10e1e66


